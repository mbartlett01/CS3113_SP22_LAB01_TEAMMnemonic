.section .data
# This example does not make use of the data section
# Creation of a temp list to run bubble sort on -> no nodes created 
data_items:
	.quad 6,5,4,3,2,1,-1
#Initialize the addresses to zero
next_address:
	.quad 0,0,0,0,0,0,0,0,0,0
previous_address:
	.quad -1,0,0,0,0,0,0,0,0,0

#sys call numebrs taken from textbook
	.equ SYS_OPEN, 2
    .equ SYS_WRITE, 1
    .equ SYS_READ, 0
    .equ SYS_CLOSE, 3
    .equ SYS_EXIT, 60
#options for open (look at
#/usr/include/asm/fcntl.h for
#various values.  You can combine them
#by adding them or ORing them)
#This is discussed at greater length
#in "Counting Like a Computer"
    .equ O_RDONLY, 0
    .equ O_CREAT_WRONLY_TRUNC, 03101
#standard file descriptors
    .equ STDIN, 0
    .equ STDOUT, 1
    .equ STDERR, 2
    
    .equ END_OF_FILE, 0  #This is the return value
                         #of read which means we’ve
                         #hit the end of the file
    .equ NUMBER_ARGUMENTS, 2
.section .bss
#Buffer - this is where the data is loaded into
#         from the data file and written from
#         into the output file.  This should
#         never exceed 16,000 for various
#         reasons.
    .equ BUFFER_SIZE, 500
    .lcomm BUFFER_DATA, BUFFER_SIZE

.section .text
# The .text section is our executable code.

#this is code taken from the textbook
#STACK POSITIONS
    .equ ST_SIZE_RESERVE, 16
    .equ ST_FD_IN, -8
    .equ ST_FD_OUT, -16
    .equ ST_ARGC, 0      #Number of arguments
    .equ ST_ARGV_0, 8   #Name of program
    .equ ST_ARGV_1, 16   #Input file name
    .equ ST_ARGV_2, 24   #Output file name

open_files:
open_fd_in:
###OPEN INPUT FILE###
  #open syscall
    movq  $SYS_OPEN, %rax          #open 
    movq  ST_ARGV_1(%rbp), %rdi    #this file
    movq  $O_RDONLY, %rsi          #with read_only flag
    movq  $0666, %rdx              #(if needed creation) with mode 666
    syscall                        #do it, file id returned in %rax
store_fd_in:
    #save the given file descriptor
    movq  %rax, ST_FD_IN(%rbp)
    
open_fd_out:
###OPEN OUTPUT FILE###
    movq  $SYS_OPEN, %rax          #open 
    movq  ST_ARGV_2(%rbp), %rdi    #this file
    movq  $O_CREAT_WRONLY_TRUNC, %rsi          #with write_only flag
    movq  $0666, %rdx              #(if needed creation) with mode 666
    syscall                        #do it, file id returned in %rax
store_fd_out:
    #store the file descriptor here
    movq  %rax, ST_FD_OUT(%rbp)
    
###BEGIN MAIN LOOP###
read_loop_begin:
    ###READ IN A BLOCK FROM THE INPUT FILE###
    movq  $SYS_READ, %rax       #read
    movq  ST_FD_IN(%rbp), %rdi  #from this file
    movq  $BUFFER_DATA, %rsi    #to this buffer
    movq  $BUFFER_SIZE, %rdx    #up to this count
    syscall                     #do it, size of buffer read is returned in %rax
    
    ###EXIT IF WE’VE REACHED THE END###
    #check for end of file marker
    cmpq  $END_OF_FILE, %rax
    #if found or on error, go to the end
    jle   end_loop

###WRITE THE BLOCK OUT TO THE OUTPUT FILE###
    #size of the buffer
    movq  %rax, %rdx              #remember buffer size
    movq  $SYS_WRITE, %rax        #write to
    movq  ST_FD_OUT(%rbp), %rdi   #to this file
    movq  $BUFFER_DATA, %rsi      #this buffer
                                  #count from %rdx
    syscall
    
    ###CONTINUE THE LOOP###
    jmp   read_loop_begin

end_loop:
    ###CLOSE THE FILES###
    #NOTE - we don’t need to do error checking
    #       on these, because error conditions
    #       don’t signify anything special here
    
    movq  $SYS_CLOSE, %rax
    movq  ST_FD_OUT(%rbp), %rdi
    syscall
    
    movq  $SYS_CLOSE, %rax
    movq  ST_FD_IN(%rbp), %rdi
    syscall
    
    ###EXIT###
    movq  $SYS_EXIT, %rax
    movq  $0, %rdi
    syscall



# We need to make the symbol _start available to the loader (ld) and we do this
# with .globl	
.globl _start
_start:
	# Fill in the addresses array
	leaq $BUFFER_DATA, %rcx
	leaq next_address, %rdx
	call _fill_in_addesses

	_break_point:

	#Sort the linked list
	leaq next_address, %rcx
	call _bubble_sort

	#Load all variable into %rab to check if it is sorted
	#Start index variable at 0
	movq $0, %rdi
	_test_loop:
		#Move each element into %rax
		movq (%rcx,%rdi,8), %rax
		movq (%rax), %rbx
		#Exit loop if last element is -1
		cmpq $-1, %rbx
		je _end_test_loop
		#Increment the index variable
		incq %rdi
		jmp _test_loop
	_end_test_loop:

	jmp _exit_x86_64bit

#fill in the next address array
#pass the data array in %rcx and the address array in %rdx
.type _fill_in_addresses, @function
_fill_in_addesses:
	# standard function stuff for call
	# 1. put the old base pointer register on the stack
	pushq	%rbp
	# 2. move the old stack pointer register
	#    to the base pointer register
	movq	%rsp, %rbp

	#Initialize the index variable
	movq $1, %rdi

	#Create a loop
	_start_address_loop:
		#Load the current value into rax
		movq (%rcx,%rdi,8), %rax
		#Load the corresponding address into the addresses array
		leaq (%rcx,%rdi,8), %rbx
		decq %rdi
		movq %rbx, (%rdx,%rdi,8)
		incq %rdi
		#Increment the counter
		incq %rdi
		#Check to see if the current value is -1 and if so, jump to the end of the loop
		cmpq $-1, %rax
		je _end_address_loop
		#Loop 
		jmp _start_address_loop
	_end_address_loop:
	
	# callee saved registers: if we used any of the callee saved
	#   we need to make sure to restore them before returning.
	
	# Standard function callee stuff
	# 1. set the stack pointer to the base pointer value.
	#    This is where the caller believe the top of the
	#    stack is located.
	movq %rbp, %rsp
	# 2. restore the base pointer
	popq %rbp

	# return 
	ret

#fill in the previous address array
#pass the data array in %rcx and the address array in %rdx
.type _fill_in_previous_addresses, @function
_fill_in_previous_addresses:
	# standard function stuff for call
	# 1. put the old base pointer register on the stack
	pushq	%rbp
	# 2. move the old stack pointer register
	#    to the base pointer register
	movq	%rsp, %rbp

	#Initialize the index variable
	movq $0x0, %rdi

	#Create a loop
	_start_prev_address_loop:
		#Load the current value into rax
		movq (%rcx,%rdi,8), %rax
		#Load the corresponding address into the addresses array
		leaq (%rcx,%rdi,8), %rbx
		incq %rdi
		movq %rbx, (%rdx,%rdi,8)
		#Check to see if the current value is -1 and if so, jump to the end of the loop
		cmpq $-1, %rax
		je _end_prev_address_loop
		#Loop 
		jmp _start_prev_address_loop
	_end_prev_address_loop:
	
	# callee saved registers: if we used any of the callee saved
	#   we need to make sure to restore them before returning.
	
	# Standard function callee stuff
	# 1. set the stack pointer to the base pointer value.
	#    This is where the caller believe the top of the
	#    stack is located.
	movq %rbp, %rsp
	# 2. restore the base pointer
	popq %rbp

	# return 
	ret

#Swap Function used in bubble sort that swaps addresses stored in %rax and %rbx
.type _swap, @function
_swap:
	# standard function stuff for call
	# 1. put the old base pointer register on the stack
	pushq	%rbp
	# 2. move the old stack pointer register
	#    to the base pointer register
	movq	%rsp, %rbp

	#swap the addresses in the addresses array
	movq %rax, (%rcx,%rdi,8)
	decq %rdi
	movq %rbx, (%rcx,%rdi,8)
	incq %rdi

	# Standard function callee stuff
	# 1. set the stack pointer to the base pointer value.
	#    This is where the caller believe the top of the
	#    stack is located.
	movq %rbp, %rsp
	# 2. restore the base pointer
	popq %rbp

	# return 
	ret

#Uses bubble sort to sort a linked list
#Passes the addresses of linked list in %rcx
.type _bubble_sort, @function
_bubble_sort:
	# standard function stuff for call
	# 1. put the old base pointer register on the stack
	pushq	%rbp
	# 2. move the old stack pointer register
	#    to the base pointer register
	movq	%rsp, %rbp

	# Start bubble sort
	#%rax first element
	#%rbx second element
	#%rdx flag saying if we have swapped (0 = no swap, 1 = swap)
	_start_outer_bubble_loop:
		#Start index variable at 0
		movq $0, %rdi
		movq $0, %rdx
		_start_inner_bubble_loop:
			#Load the address of the first two values into %rax and %rbx
			movq (%rcx,%rdi,8), %rax
			incq %rdi
			movq (%rcx,%rdi,8), %rbx
			#Exit loop if last element is -1
			cmpq $-1, (%rbx)
			je _end_inner_bubble_loop
			#Compare the values and swap if necessary
			#Push the addresses to reduce register use
			pushq %rax
			pushq %rbx
			pushq (%rax)
			pushq (%rbx)
			#Get the actual values at the addresses
			popq %rbx
			popq %rax
			#Compare the value of the two elements
			cmpq %rbx, %rax
			#Return the addresses to the registers
			popq %rbx
			popq %rax
			#Decide to swap or not
			jle _no_swap
			call _swap
			#Set the swap flag to true
			movq $1, %rdx
			_no_swap:
			jmp _start_inner_bubble_loop
		_end_inner_bubble_loop:
		#Check to see if no swaps occurred
		cmpq $0, %rdx
		je _end_outer_bubble_loop
		jmp _start_outer_bubble_loop
	_end_outer_bubble_loop:

	# Standard function callee stuff
	# 1. set the stack pointer to the base pointer value.
	#    This is where the caller believe the top of the
	#    stack is located.
	movq %rbp, %rsp
	# 2. restore the base pointer
	popq %rbp

	# return 
	ret

#Uses Insertion sort to sort a linked list
#Passes the addresses of linked list in %rcx
#Uses %rax, %rbx, %rdi, %rsi
.type _insertion_sort, @function
_insertion_sort:
	# standard function stuff for call
	# 1. put the old base pointer register on the stack
	pushq	%rbp
	# 2. move the old stack pointer register
	#    to the base pointer register
	movq	%rsp, %rbp

	#%rdi outer loop index
	#%rsi inner loop index
	#Start insertion sort
	#Initialize the index variables
	movq $1, %rdi
	_start_outer_insertion_loop:
		#Load the value we are currently moving into %rax
		movq (%rcx,%rdi,8), %rax
		#Break out of the loop if the value is -1
		cmpq $-1, (%rax)
		je _end_outer_insertion_loop
		#Reset the inner loop index
		movq %rdi, %rsi
		decq %rsi
		#Start inner loop
		_start_inner_insertion_loop:
			#Load the next value to compare into %rbx
			movq (%rcx,%rsi,8), %rbx
			#Compare the values and shift if necessary
			#Push the addresses to reduce register use
			pushq %rax
			pushq %rbx
			pushq (%rax)
			pushq (%rbx)
			#Get the actual values at the addresses
			popq %rbx
			popq %rax
			#Compare the value of the two elements
			cmpq %rbx, %rax
			#Return the addresses to the registers
			popq %rbx
			popq %rax
			#Determine if we need to shift or insert
			jge _end_inner_insertion_loop
			#Shift the value by 1 if you are not inserting it
			#shift the value in %rbx to the right by one
			incq %rsi
			movq %rbx, (%rcx,%rsi,8)
			decq %rsi
			#Check to see if we need to break out of the loop
			decq %rsi
			cmpq $-1, %rsi
			je _end_inner_insertion_loop
			#Jump back to start of the inner loop
			jmp _start_inner_insertion_loop
		_end_inner_insertion_loop:
		#insert the value into the correct position
		incq %rsi
		movq %rax, (%rcx,%rsi,8)
		#Jump back to the start of the outer loop
		incq %rdi
		jmp _start_outer_insertion_loop
	_end_outer_insertion_loop:

	# Standard function callee stuff
	# 1. set the stack pointer to the base pointer value.
	#    This is where the caller believe the top of the
	#    stack is located.
	movq %rbp, %rsp
	# 2. restore the base pointer
	popq %rbp

	# return 
	ret

_exit_x86_64bit:
	# This is slightly different because in x86_64 (64bit) we get the
	# syscall instruction, which provides more flexibility than int (interrupt)
	# so it is the defacto way for making system calls in 64bit binaries, in linux,
	# on systems with the x86_64 instruction set architecture.
	movq $60, %rax  # call number 60 -> exit
	movq $0x0, %rdi # return 0
	syscall #run kernel
	
	